/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/draggabilly";
exports.ids = ["vendor-chunks/draggabilly"];
exports.modules = {

/***/ "(ssr)/./node_modules/draggabilly/draggabilly.js":
/*!*************************************************!*\
  !*** ./node_modules/draggabilly/draggabilly.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*!\n * Draggabilly v3.0.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n( function( window, factory ) {\n  // universal module definition\n  if (  true && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n        window,\n        __webpack_require__(/*! get-size */ \"(ssr)/./node_modules/get-size/get-size.js\"),\n        __webpack_require__(/*! unidragger */ \"(ssr)/./node_modules/unidragger/unidragger.js\"),\n    );\n  } else {\n    // browser global\n    window.Draggabilly = factory(\n        window,\n        window.getSize,\n        window.Unidragger,\n    );\n  }\n\n}( typeof window != 'undefined' ? window : this,\n    function factory( window, getSize, Unidragger ) {\n\n// -------------------------- helpers & variables -------------------------- //\n\nfunction noop() {}\n\nlet jQuery = window.jQuery;\n\n// -------------------------- Draggabilly -------------------------- //\n\nfunction Draggabilly( element, options ) {\n  // querySelector if string\n  this.element = typeof element == 'string' ?\n    document.querySelector( element ) : element;\n\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n\n  // options\n  this.options = {};\n  this.option( options );\n\n  this._create();\n}\n\n// inherit Unidragger methods\nlet proto = Draggabilly.prototype = Object.create( Unidragger.prototype );\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  this.options = {\n    ...this.options,\n    ...opts,\n  };\n};\n\n// css position values that don't need to be set\nconst positionValues = [ 'relative', 'absolute', 'fixed' ];\n\nproto._create = function() {\n  // properties\n  this.position = {};\n  this._getPosition();\n\n  this.startPoint = { x: 0, y: 0 };\n  this.dragPoint = { x: 0, y: 0 };\n\n  this.startPosition = { ...this.position };\n\n  // set relative positioning\n  let style = getComputedStyle( this.element );\n  if ( !positionValues.includes( style.position ) ) {\n    this.element.style.position = 'relative';\n  }\n\n  // events\n  this.on( 'pointerDown', this.handlePointerDown );\n  this.on( 'pointerUp', this.handlePointerUp );\n  this.on( 'dragStart', this.handleDragStart );\n  this.on( 'dragMove', this.handleDragMove );\n  this.on( 'dragEnd', this.handleDragEnd );\n\n  this.setHandles();\n  this.enable();\n};\n\n// set this.handles  and bind start events to 'em\nproto.setHandles = function() {\n  let { handle } = this.options;\n  if ( typeof handle == 'string' ) {\n    this.handles = this.element.querySelectorAll( handle );\n  } else if ( typeof handle == 'object' && handle.length ) {\n    this.handles = handle;\n  } else if ( handle instanceof HTMLElement ) {\n    this.handles = [ handle ];\n  } else {\n    this.handles = [ this.element ];\n  }\n};\n\nconst cancelableEvents = [ 'dragStart', 'dragMove', 'dragEnd' ];\n\n// duck-punch emitEvent to dispatch jQuery events as well\nlet emitEvent = proto.emitEvent;\nproto.emitEvent = function( eventName, args ) {\n  // do not emit cancelable events if dragging is disabled\n  let isCanceled = !this.isEnabled && cancelableEvents.includes( eventName );\n  if ( isCanceled ) return;\n\n  emitEvent.call( this, eventName, args );\n\n  // trigger jQuery event\n  let jquery = window.jQuery;\n  if ( !jquery || !this.$element ) return;\n  // create jQuery event\n  let event;\n  let jqArgs = args;\n  let isFirstArgEvent = args && args[0] instanceof Event;\n  if ( isFirstArgEvent ) [ event, ...jqArgs ] = args;\n  /* eslint-disable-next-line new-cap */\n  let $event = jquery.Event( event );\n  $event.type = eventName;\n  this.$element.trigger( $event, jqArgs );\n};\n\n// -------------------------- position -------------------------- //\n\n// get x/y position from style\nproto._getPosition = function() {\n  let style = getComputedStyle( this.element );\n  let x = this._getPositionCoord( style.left, 'width' );\n  let y = this._getPositionCoord( style.top, 'height' );\n  // clean up 'auto' or other non-integer values\n  this.position.x = isNaN( x ) ? 0 : x;\n  this.position.y = isNaN( y ) ? 0 : y;\n\n  this._addTransformPosition( style );\n};\n\nproto._getPositionCoord = function( styleSide, measure ) {\n  if ( styleSide.includes('%') ) {\n    // convert percent into pixel for Safari, #75\n    let parentSize = getSize( this.element.parentNode );\n    // prevent not-in-DOM element throwing bug, #131\n    return !parentSize ? 0 :\n      ( parseFloat( styleSide ) / 100 ) * parentSize[ measure ];\n  }\n  return parseInt( styleSide, 10 );\n};\n\n// add transform: translate( x, y ) to position\nproto._addTransformPosition = function( style ) {\n  let transform = style.transform;\n  // bail out if value is 'none'\n  if ( !transform.startsWith('matrix') ) return;\n\n  // split matrix(1, 0, 0, 1, x, y)\n  let matrixValues = transform.split(',');\n  // translate X value is in 12th or 4th position\n  let xIndex = transform.startsWith('matrix3d') ? 12 : 4;\n  let translateX = parseInt( matrixValues[ xIndex ], 10 );\n  // translate Y value is in 13th or 5th position\n  let translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );\n  this.position.x += translateX;\n  this.position.y += translateY;\n};\n\n// -------------------------- events -------------------------- //\n\nproto.handlePointerDown = function( event, pointer ) {\n  if ( !this.isEnabled ) return;\n  // track start event position\n  // Safari 9 overrides pageX and pageY. These values needs to be copied. flickity#842\n  this.pointerDownPointer = {\n    pageX: pointer.pageX,\n    pageY: pointer.pageY,\n  };\n\n  event.preventDefault();\n  document.activeElement.blur();\n  // bind move and end events\n  this.bindActivePointerEvents( event );\n  this.element.classList.add('is-pointer-down');\n};\n\nproto.handleDragStart = function() {\n  if ( !this.isEnabled ) return;\n\n  this._getPosition();\n  this.measureContainment();\n  // position _when_ drag began\n  this.startPosition.x = this.position.x;\n  this.startPosition.y = this.position.y;\n  // reset left/top style\n  this.setLeftTop();\n\n  this.dragPoint.x = 0;\n  this.dragPoint.y = 0;\n\n  this.element.classList.add('is-dragging');\n  // start animation\n  this.animate();\n};\n\nproto.measureContainment = function() {\n  let container = this.getContainer();\n  if ( !container ) return;\n\n  let elemSize = getSize( this.element );\n  let containerSize = getSize( container );\n  let {\n    borderLeftWidth,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = containerSize;\n  let elemRect = this.element.getBoundingClientRect();\n  let containerRect = container.getBoundingClientRect();\n\n  let borderSizeX = borderLeftWidth + borderRightWidth;\n  let borderSizeY = borderTopWidth + borderBottomWidth;\n\n  let position = this.relativeStartPosition = {\n    x: elemRect.left - ( containerRect.left + borderLeftWidth ),\n    y: elemRect.top - ( containerRect.top + borderTopWidth ),\n  };\n\n  this.containSize = {\n    width: ( containerSize.width - borderSizeX ) - position.x - elemSize.width,\n    height: ( containerSize.height - borderSizeY ) - position.y - elemSize.height,\n  };\n};\n\nproto.getContainer = function() {\n  let containment = this.options.containment;\n  if ( !containment ) return;\n\n  let isElement = containment instanceof HTMLElement;\n  // use as element\n  if ( isElement ) return containment;\n\n  // querySelector if string\n  if ( typeof containment == 'string' ) {\n    return document.querySelector( containment );\n  }\n  // fallback to parent element\n  return this.element.parentNode;\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event | Touch} pointer\n * @param {Object} moveVector - x and y coordinates\n */\nproto.handleDragMove = function( event, pointer, moveVector ) {\n  if ( !this.isEnabled ) return;\n\n  let dragX = moveVector.x;\n  let dragY = moveVector.y;\n\n  let grid = this.options.grid;\n  let gridX = grid && grid[0];\n  let gridY = grid && grid[1];\n\n  dragX = applyGrid( dragX, gridX );\n  dragY = applyGrid( dragY, gridY );\n\n  dragX = this.containDrag( 'x', dragX, gridX );\n  dragY = this.containDrag( 'y', dragY, gridY );\n\n  // constrain to axis\n  dragX = this.options.axis == 'y' ? 0 : dragX;\n  dragY = this.options.axis == 'x' ? 0 : dragY;\n\n  this.position.x = this.startPosition.x + dragX;\n  this.position.y = this.startPosition.y + dragY;\n  // set dragPoint properties\n  this.dragPoint.x = dragX;\n  this.dragPoint.y = dragY;\n};\n\nfunction applyGrid( value, grid, method ) {\n  if ( !grid ) return value;\n\n  method = method || 'round';\n  return Math[ method ]( value/grid ) * grid;\n}\n\nproto.containDrag = function( axis, drag, grid ) {\n  if ( !this.options.containment ) return drag;\n\n  let measure = axis == 'x' ? 'width' : 'height';\n\n  let rel = this.relativeStartPosition[ axis ];\n  let min = applyGrid( -rel, grid, 'ceil' );\n  let max = this.containSize[ measure ];\n  max = applyGrid( max, grid, 'floor' );\n  return Math.max( min, Math.min( max, drag ) );\n};\n\n// ----- end event ----- //\n\nproto.handlePointerUp = function() {\n  this.element.classList.remove('is-pointer-down');\n};\n\nproto.handleDragEnd = function() {\n  if ( !this.isEnabled ) return;\n\n  // use top left position when complete\n  this.element.style.transform = '';\n  this.setLeftTop();\n  this.element.classList.remove('is-dragging');\n};\n\n// -------------------------- animation -------------------------- //\n\nproto.animate = function() {\n  // only render and animate if dragging\n  if ( !this.isDragging ) return;\n\n  this.positionDrag();\n  requestAnimationFrame( () => this.animate() );\n};\n\n// left/top positioning\nproto.setLeftTop = function() {\n  let { x, y } = this.position;\n  this.element.style.left = `${x}px`;\n  this.element.style.top = `${y}px`;\n};\n\nproto.positionDrag = function() {\n  let { x, y } = this.dragPoint;\n  this.element.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n};\n\n// ----- methods ----- //\n\n/**\n * @param {Number} x\n * @param {Number} y\n */\nproto.setPosition = function( x, y ) {\n  this.position.x = x;\n  this.position.y = y;\n  this.setLeftTop();\n};\n\nproto.enable = function() {\n  if ( this.isEnabled ) return;\n  this.isEnabled = true;\n  this.bindHandles();\n};\n\nproto.disable = function() {\n  if ( !this.isEnabled ) return;\n  this.isEnabled = false;\n  if ( this.isDragging ) this.dragEnd();\n  this.unbindHandles();\n};\n\nconst resetCssProperties = [ 'transform', 'left', 'top', 'position' ];\n\nproto.destroy = function() {\n  this.disable();\n  // reset styles\n  resetCssProperties.forEach( ( prop ) => {\n    this.element.style[ prop ] = '';\n  } );\n  // unbind handles\n  this.unbindHandles();\n  // remove jQuery data\n  if ( this.$element ) this.$element.removeData('draggabilly');\n};\n\n// ----- jQuery bridget ----- //\n\n// required for jQuery bridget\nproto._init = noop;\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'draggabilly', Draggabilly );\n}\n\n// -----  ----- //\n\nreturn Draggabilly;\n\n} ) );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZHJhZ2dhYmlsbHkvZHJhZ2dhYmlsbHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLEtBQXlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQywyREFBVTtBQUMxQixRQUFRLG1CQUFPLENBQUMsaUVBQVk7QUFDNUI7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIscUJBQXFCOztBQUVyQix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmLCtCQUErQixFQUFFO0FBQ2pDLDhCQUE4QixFQUFFO0FBQ2hDOztBQUVBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsZ0RBQWdELEVBQUUsTUFBTSxFQUFFO0FBQzFEOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZWZpZ2h0ZXItd2ViLy4vbm9kZV9tb2R1bGVzL2RyYWdnYWJpbGx5L2RyYWdnYWJpbGx5LmpzPzUxMzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEcmFnZ2FiaWxseSB2My4wLjBcbiAqIE1ha2UgdGhhdCBzaGl6IGRyYWdnYWJsZVxuICogaHR0cHM6Ly9kcmFnZ2FiaWxseS5kZXNhbmRyby5jb21cbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHJlcXVpcmUoJ2dldC1zaXplJyksXG4gICAgICAgIHJlcXVpcmUoJ3VuaWRyYWdnZXInKSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LkRyYWdnYWJpbGx5ID0gZmFjdG9yeShcbiAgICAgICAgd2luZG93LFxuICAgICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgICAgd2luZG93LlVuaWRyYWdnZXIsXG4gICAgKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyxcbiAgICBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGhlbHBlcnMgJiB2YXJpYWJsZXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmxldCBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEcmFnZ2FiaWxseSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBEcmFnZ2FiaWxseSggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgLy8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcbiAgdGhpcy5lbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW1lbnQgKSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gIH1cblxuICAvLyBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLm9wdGlvbiggb3B0aW9ucyApO1xuXG4gIHRoaXMuX2NyZWF0ZSgpO1xufVxuXG4vLyBpbmhlcml0IFVuaWRyYWdnZXIgbWV0aG9kc1xubGV0IHByb3RvID0gRHJhZ2dhYmlsbHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pZHJhZ2dlci5wcm90b3R5cGUgKTtcblxuLyoqXG4gKiBzZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xucHJvdG8ub3B0aW9uID0gZnVuY3Rpb24oIG9wdHMgKSB7XG4gIHRoaXMub3B0aW9ucyA9IHtcbiAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgLi4ub3B0cyxcbiAgfTtcbn07XG5cbi8vIGNzcyBwb3NpdGlvbiB2YWx1ZXMgdGhhdCBkb24ndCBuZWVkIHRvIGJlIHNldFxuY29uc3QgcG9zaXRpb25WYWx1ZXMgPSBbICdyZWxhdGl2ZScsICdhYnNvbHV0ZScsICdmaXhlZCcgXTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBwcm9wZXJ0aWVzXG4gIHRoaXMucG9zaXRpb24gPSB7fTtcbiAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcblxuICB0aGlzLnN0YXJ0UG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgdGhpcy5kcmFnUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcblxuICB0aGlzLnN0YXJ0UG9zaXRpb24gPSB7IC4uLnRoaXMucG9zaXRpb24gfTtcblxuICAvLyBzZXQgcmVsYXRpdmUgcG9zaXRpb25pbmdcbiAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50ICk7XG4gIGlmICggIXBvc2l0aW9uVmFsdWVzLmluY2x1ZGVzKCBzdHlsZS5wb3NpdGlvbiApICkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIH1cblxuICAvLyBldmVudHNcbiAgdGhpcy5vbiggJ3BvaW50ZXJEb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93biApO1xuICB0aGlzLm9uKCAncG9pbnRlclVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXAgKTtcbiAgdGhpcy5vbiggJ2RyYWdTdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ICk7XG4gIHRoaXMub24oICdkcmFnTW92ZScsIHRoaXMuaGFuZGxlRHJhZ01vdmUgKTtcbiAgdGhpcy5vbiggJ2RyYWdFbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQgKTtcblxuICB0aGlzLnNldEhhbmRsZXMoKTtcbiAgdGhpcy5lbmFibGUoKTtcbn07XG5cbi8vIHNldCB0aGlzLmhhbmRsZXMgIGFuZCBiaW5kIHN0YXJ0IGV2ZW50cyB0byAnZW1cbnByb3RvLnNldEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHsgaGFuZGxlIH0gPSB0aGlzLm9wdGlvbnM7XG4gIGlmICggdHlwZW9mIGhhbmRsZSA9PSAnc3RyaW5nJyApIHtcbiAgICB0aGlzLmhhbmRsZXMgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggaGFuZGxlICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBoYW5kbGUgPT0gJ29iamVjdCcgJiYgaGFuZGxlLmxlbmd0aCApIHtcbiAgICB0aGlzLmhhbmRsZXMgPSBoYW5kbGU7XG4gIH0gZWxzZSBpZiAoIGhhbmRsZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICkge1xuICAgIHRoaXMuaGFuZGxlcyA9IFsgaGFuZGxlIF07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5oYW5kbGVzID0gWyB0aGlzLmVsZW1lbnQgXTtcbiAgfVxufTtcblxuY29uc3QgY2FuY2VsYWJsZUV2ZW50cyA9IFsgJ2RyYWdTdGFydCcsICdkcmFnTW92ZScsICdkcmFnRW5kJyBdO1xuXG4vLyBkdWNrLXB1bmNoIGVtaXRFdmVudCB0byBkaXNwYXRjaCBqUXVlcnkgZXZlbnRzIGFzIHdlbGxcbmxldCBlbWl0RXZlbnQgPSBwcm90by5lbWl0RXZlbnQ7XG5wcm90by5lbWl0RXZlbnQgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBhcmdzICkge1xuICAvLyBkbyBub3QgZW1pdCBjYW5jZWxhYmxlIGV2ZW50cyBpZiBkcmFnZ2luZyBpcyBkaXNhYmxlZFxuICBsZXQgaXNDYW5jZWxlZCA9ICF0aGlzLmlzRW5hYmxlZCAmJiBjYW5jZWxhYmxlRXZlbnRzLmluY2x1ZGVzKCBldmVudE5hbWUgKTtcbiAgaWYgKCBpc0NhbmNlbGVkICkgcmV0dXJuO1xuXG4gIGVtaXRFdmVudC5jYWxsKCB0aGlzLCBldmVudE5hbWUsIGFyZ3MgKTtcblxuICAvLyB0cmlnZ2VyIGpRdWVyeSBldmVudFxuICBsZXQganF1ZXJ5ID0gd2luZG93LmpRdWVyeTtcbiAgaWYgKCAhanF1ZXJ5IHx8ICF0aGlzLiRlbGVtZW50ICkgcmV0dXJuO1xuICAvLyBjcmVhdGUgalF1ZXJ5IGV2ZW50XG4gIGxldCBldmVudDtcbiAgbGV0IGpxQXJncyA9IGFyZ3M7XG4gIGxldCBpc0ZpcnN0QXJnRXZlbnQgPSBhcmdzICYmIGFyZ3NbMF0gaW5zdGFuY2VvZiBFdmVudDtcbiAgaWYgKCBpc0ZpcnN0QXJnRXZlbnQgKSBbIGV2ZW50LCAuLi5qcUFyZ3MgXSA9IGFyZ3M7XG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwICovXG4gIGxldCAkZXZlbnQgPSBqcXVlcnkuRXZlbnQoIGV2ZW50ICk7XG4gICRldmVudC50eXBlID0gZXZlbnROYW1lO1xuICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwganFBcmdzICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwb3NpdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgeC95IHBvc2l0aW9uIGZyb20gc3R5bGVcbnByb3RvLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgbGV0IHggPSB0aGlzLl9nZXRQb3NpdGlvbkNvb3JkKCBzdHlsZS5sZWZ0LCAnd2lkdGgnICk7XG4gIGxldCB5ID0gdGhpcy5fZ2V0UG9zaXRpb25Db29yZCggc3R5bGUudG9wLCAnaGVpZ2h0JyApO1xuICAvLyBjbGVhbiB1cCAnYXV0bycgb3Igb3RoZXIgbm9uLWludGVnZXIgdmFsdWVzXG4gIHRoaXMucG9zaXRpb24ueCA9IGlzTmFOKCB4ICkgPyAwIDogeDtcbiAgdGhpcy5wb3NpdGlvbi55ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xuXG4gIHRoaXMuX2FkZFRyYW5zZm9ybVBvc2l0aW9uKCBzdHlsZSApO1xufTtcblxucHJvdG8uX2dldFBvc2l0aW9uQ29vcmQgPSBmdW5jdGlvbiggc3R5bGVTaWRlLCBtZWFzdXJlICkge1xuICBpZiAoIHN0eWxlU2lkZS5pbmNsdWRlcygnJScpICkge1xuICAgIC8vIGNvbnZlcnQgcGVyY2VudCBpbnRvIHBpeGVsIGZvciBTYWZhcmksICM3NVxuICAgIGxldCBwYXJlbnRTaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgKTtcbiAgICAvLyBwcmV2ZW50IG5vdC1pbi1ET00gZWxlbWVudCB0aHJvd2luZyBidWcsICMxMzFcbiAgICByZXR1cm4gIXBhcmVudFNpemUgPyAwIDpcbiAgICAgICggcGFyc2VGbG9hdCggc3R5bGVTaWRlICkgLyAxMDAgKSAqIHBhcmVudFNpemVbIG1lYXN1cmUgXTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQoIHN0eWxlU2lkZSwgMTAgKTtcbn07XG5cbi8vIGFkZCB0cmFuc2Zvcm06IHRyYW5zbGF0ZSggeCwgeSApIHRvIHBvc2l0aW9uXG5wcm90by5fYWRkVHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIGxldCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm07XG4gIC8vIGJhaWwgb3V0IGlmIHZhbHVlIGlzICdub25lJ1xuICBpZiAoICF0cmFuc2Zvcm0uc3RhcnRzV2l0aCgnbWF0cml4JykgKSByZXR1cm47XG5cbiAgLy8gc3BsaXQgbWF0cml4KDEsIDAsIDAsIDEsIHgsIHkpXG4gIGxldCBtYXRyaXhWYWx1ZXMgPSB0cmFuc2Zvcm0uc3BsaXQoJywnKTtcbiAgLy8gdHJhbnNsYXRlIFggdmFsdWUgaXMgaW4gMTJ0aCBvciA0dGggcG9zaXRpb25cbiAgbGV0IHhJbmRleCA9IHRyYW5zZm9ybS5zdGFydHNXaXRoKCdtYXRyaXgzZCcpID8gMTIgOiA0O1xuICBsZXQgdHJhbnNsYXRlWCA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCBdLCAxMCApO1xuICAvLyB0cmFuc2xhdGUgWSB2YWx1ZSBpcyBpbiAxM3RoIG9yIDV0aCBwb3NpdGlvblxuICBsZXQgdHJhbnNsYXRlWSA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCArIDEgXSwgMTAgKTtcbiAgdGhpcy5wb3NpdGlvbi54ICs9IHRyYW5zbGF0ZVg7XG4gIHRoaXMucG9zaXRpb24ueSArPSB0cmFuc2xhdGVZO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLmhhbmRsZVBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHJldHVybjtcbiAgLy8gdHJhY2sgc3RhcnQgZXZlbnQgcG9zaXRpb25cbiAgLy8gU2FmYXJpIDkgb3ZlcnJpZGVzIHBhZ2VYIGFuZCBwYWdlWS4gVGhlc2UgdmFsdWVzIG5lZWRzIHRvIGJlIGNvcGllZC4gZmxpY2tpdHkjODQyXG4gIHRoaXMucG9pbnRlckRvd25Qb2ludGVyID0ge1xuICAgIHBhZ2VYOiBwb2ludGVyLnBhZ2VYLFxuICAgIHBhZ2VZOiBwb2ludGVyLnBhZ2VZLFxuICB9O1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAvLyBiaW5kIG1vdmUgYW5kIGVuZCBldmVudHNcbiAgdGhpcy5iaW5kQWN0aXZlUG9pbnRlckV2ZW50cyggZXZlbnQgKTtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLXBvaW50ZXItZG93bicpO1xufTtcblxucHJvdG8uaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuaXNFbmFibGVkICkgcmV0dXJuO1xuXG4gIHRoaXMuX2dldFBvc2l0aW9uKCk7XG4gIHRoaXMubWVhc3VyZUNvbnRhaW5tZW50KCk7XG4gIC8vIHBvc2l0aW9uIF93aGVuXyBkcmFnIGJlZ2FuXG4gIHRoaXMuc3RhcnRQb3NpdGlvbi54ID0gdGhpcy5wb3NpdGlvbi54O1xuICB0aGlzLnN0YXJ0UG9zaXRpb24ueSA9IHRoaXMucG9zaXRpb24ueTtcbiAgLy8gcmVzZXQgbGVmdC90b3Agc3R5bGVcbiAgdGhpcy5zZXRMZWZ0VG9wKCk7XG5cbiAgdGhpcy5kcmFnUG9pbnQueCA9IDA7XG4gIHRoaXMuZHJhZ1BvaW50LnkgPSAwO1xuXG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpcy1kcmFnZ2luZycpO1xuICAvLyBzdGFydCBhbmltYXRpb25cbiAgdGhpcy5hbmltYXRlKCk7XG59O1xuXG5wcm90by5tZWFzdXJlQ29udGFpbm1lbnQgPSBmdW5jdGlvbigpIHtcbiAgbGV0IGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gIGlmICggIWNvbnRhaW5lciApIHJldHVybjtcblxuICBsZXQgZWxlbVNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgbGV0IGNvbnRhaW5lclNpemUgPSBnZXRTaXplKCBjb250YWluZXIgKTtcbiAgbGV0IHtcbiAgICBib3JkZXJMZWZ0V2lkdGgsXG4gICAgYm9yZGVyUmlnaHRXaWR0aCxcbiAgICBib3JkZXJUb3BXaWR0aCxcbiAgICBib3JkZXJCb3R0b21XaWR0aCxcbiAgfSA9IGNvbnRhaW5lclNpemU7XG4gIGxldCBlbGVtUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgbGV0IGJvcmRlclNpemVYID0gYm9yZGVyTGVmdFdpZHRoICsgYm9yZGVyUmlnaHRXaWR0aDtcbiAgbGV0IGJvcmRlclNpemVZID0gYm9yZGVyVG9wV2lkdGggKyBib3JkZXJCb3R0b21XaWR0aDtcblxuICBsZXQgcG9zaXRpb24gPSB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvbiA9IHtcbiAgICB4OiBlbGVtUmVjdC5sZWZ0IC0gKCBjb250YWluZXJSZWN0LmxlZnQgKyBib3JkZXJMZWZ0V2lkdGggKSxcbiAgICB5OiBlbGVtUmVjdC50b3AgLSAoIGNvbnRhaW5lclJlY3QudG9wICsgYm9yZGVyVG9wV2lkdGggKSxcbiAgfTtcblxuICB0aGlzLmNvbnRhaW5TaXplID0ge1xuICAgIHdpZHRoOiAoIGNvbnRhaW5lclNpemUud2lkdGggLSBib3JkZXJTaXplWCApIC0gcG9zaXRpb24ueCAtIGVsZW1TaXplLndpZHRoLFxuICAgIGhlaWdodDogKCBjb250YWluZXJTaXplLmhlaWdodCAtIGJvcmRlclNpemVZICkgLSBwb3NpdGlvbi55IC0gZWxlbVNpemUuaGVpZ2h0LFxuICB9O1xufTtcblxucHJvdG8uZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIGxldCBjb250YWlubWVudCA9IHRoaXMub3B0aW9ucy5jb250YWlubWVudDtcbiAgaWYgKCAhY29udGFpbm1lbnQgKSByZXR1cm47XG5cbiAgbGV0IGlzRWxlbWVudCA9IGNvbnRhaW5tZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIC8vIHVzZSBhcyBlbGVtZW50XG4gIGlmICggaXNFbGVtZW50ICkgcmV0dXJuIGNvbnRhaW5tZW50O1xuXG4gIC8vIHF1ZXJ5U2VsZWN0b3IgaWYgc3RyaW5nXG4gIGlmICggdHlwZW9mIGNvbnRhaW5tZW50ID09ICdzdHJpbmcnICkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBjb250YWlubWVudCApO1xuICB9XG4gIC8vIGZhbGxiYWNrIHRvIHBhcmVudCBlbGVtZW50XG4gIHJldHVybiB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbn07XG5cbi8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBkcmFnIG1vdmVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IHwgVG91Y2h9IHBvaW50ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb3ZlVmVjdG9yIC0geCBhbmQgeSBjb29yZGluYXRlc1xuICovXG5wcm90by5oYW5kbGVEcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSByZXR1cm47XG5cbiAgbGV0IGRyYWdYID0gbW92ZVZlY3Rvci54O1xuICBsZXQgZHJhZ1kgPSBtb3ZlVmVjdG9yLnk7XG5cbiAgbGV0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgbGV0IGdyaWRYID0gZ3JpZCAmJiBncmlkWzBdO1xuICBsZXQgZ3JpZFkgPSBncmlkICYmIGdyaWRbMV07XG5cbiAgZHJhZ1ggPSBhcHBseUdyaWQoIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IGFwcGx5R3JpZCggZHJhZ1ksIGdyaWRZICk7XG5cbiAgZHJhZ1ggPSB0aGlzLmNvbnRhaW5EcmFnKCAneCcsIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IHRoaXMuY29udGFpbkRyYWcoICd5JywgZHJhZ1ksIGdyaWRZICk7XG5cbiAgLy8gY29uc3RyYWluIHRvIGF4aXNcbiAgZHJhZ1ggPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneScgPyAwIDogZHJhZ1g7XG4gIGRyYWdZID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3gnID8gMCA6IGRyYWdZO1xuXG4gIHRoaXMucG9zaXRpb24ueCA9IHRoaXMuc3RhcnRQb3NpdGlvbi54ICsgZHJhZ1g7XG4gIHRoaXMucG9zaXRpb24ueSA9IHRoaXMuc3RhcnRQb3NpdGlvbi55ICsgZHJhZ1k7XG4gIC8vIHNldCBkcmFnUG9pbnQgcHJvcGVydGllc1xuICB0aGlzLmRyYWdQb2ludC54ID0gZHJhZ1g7XG4gIHRoaXMuZHJhZ1BvaW50LnkgPSBkcmFnWTtcbn07XG5cbmZ1bmN0aW9uIGFwcGx5R3JpZCggdmFsdWUsIGdyaWQsIG1ldGhvZCApIHtcbiAgaWYgKCAhZ3JpZCApIHJldHVybiB2YWx1ZTtcblxuICBtZXRob2QgPSBtZXRob2QgfHwgJ3JvdW5kJztcbiAgcmV0dXJuIE1hdGhbIG1ldGhvZCBdKCB2YWx1ZS9ncmlkICkgKiBncmlkO1xufVxuXG5wcm90by5jb250YWluRHJhZyA9IGZ1bmN0aW9uKCBheGlzLCBkcmFnLCBncmlkICkge1xuICBpZiAoICF0aGlzLm9wdGlvbnMuY29udGFpbm1lbnQgKSByZXR1cm4gZHJhZztcblxuICBsZXQgbWVhc3VyZSA9IGF4aXMgPT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGxldCByZWwgPSB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvblsgYXhpcyBdO1xuICBsZXQgbWluID0gYXBwbHlHcmlkKCAtcmVsLCBncmlkLCAnY2VpbCcgKTtcbiAgbGV0IG1heCA9IHRoaXMuY29udGFpblNpemVbIG1lYXN1cmUgXTtcbiAgbWF4ID0gYXBwbHlHcmlkKCBtYXgsIGdyaWQsICdmbG9vcicgKTtcbiAgcmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGRyYWcgKSApO1xufTtcblxuLy8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLmhhbmRsZVBvaW50ZXJVcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtcG9pbnRlci1kb3duJyk7XG59O1xuXG5wcm90by5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuaXNFbmFibGVkICkgcmV0dXJuO1xuXG4gIC8vIHVzZSB0b3AgbGVmdCBwb3NpdGlvbiB3aGVuIGNvbXBsZXRlXG4gIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgdGhpcy5zZXRMZWZ0VG9wKCk7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kcmFnZ2luZycpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYW5pbWF0aW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLmFuaW1hdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gb25seSByZW5kZXIgYW5kIGFuaW1hdGUgaWYgZHJhZ2dpbmdcbiAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkgcmV0dXJuO1xuXG4gIHRoaXMucG9zaXRpb25EcmFnKCk7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSggKCkgPT4gdGhpcy5hbmltYXRlKCkgKTtcbn07XG5cbi8vIGxlZnQvdG9wIHBvc2l0aW9uaW5nXG5wcm90by5zZXRMZWZ0VG9wID0gZnVuY3Rpb24oKSB7XG4gIGxldCB7IHgsIHkgfSA9IHRoaXMucG9zaXRpb247XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7eH1weGA7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSBgJHt5fXB4YDtcbn07XG5cbnByb3RvLnBvc2l0aW9uRHJhZyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgeyB4LCB5IH0gPSB0aGlzLmRyYWdQb2ludDtcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsICR7eX1weCwgMClgO1xufTtcblxuLy8gLS0tLS0gbWV0aG9kcyAtLS0tLSAvL1xuXG4vKipcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICovXG5wcm90by5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCB4LCB5ICkge1xuICB0aGlzLnBvc2l0aW9uLnggPSB4O1xuICB0aGlzLnBvc2l0aW9uLnkgPSB5O1xuICB0aGlzLnNldExlZnRUb3AoKTtcbn07XG5cbnByb3RvLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMuaXNFbmFibGVkICkgcmV0dXJuO1xuICB0aGlzLmlzRW5hYmxlZCA9IHRydWU7XG4gIHRoaXMuYmluZEhhbmRsZXMoKTtcbn07XG5cbnByb3RvLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSByZXR1cm47XG4gIHRoaXMuaXNFbmFibGVkID0gZmFsc2U7XG4gIGlmICggdGhpcy5pc0RyYWdnaW5nICkgdGhpcy5kcmFnRW5kKCk7XG4gIHRoaXMudW5iaW5kSGFuZGxlcygpO1xufTtcblxuY29uc3QgcmVzZXRDc3NQcm9wZXJ0aWVzID0gWyAndHJhbnNmb3JtJywgJ2xlZnQnLCAndG9wJywgJ3Bvc2l0aW9uJyBdO1xuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGlzYWJsZSgpO1xuICAvLyByZXNldCBzdHlsZXNcbiAgcmVzZXRDc3NQcm9wZXJ0aWVzLmZvckVhY2goICggcHJvcCApID0+IHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGVbIHByb3AgXSA9ICcnO1xuICB9ICk7XG4gIC8vIHVuYmluZCBoYW5kbGVzXG4gIHRoaXMudW5iaW5kSGFuZGxlcygpO1xuICAvLyByZW1vdmUgalF1ZXJ5IGRhdGFcbiAgaWYgKCB0aGlzLiRlbGVtZW50ICkgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdkcmFnZ2FiaWxseScpO1xufTtcblxuLy8gLS0tLS0galF1ZXJ5IGJyaWRnZXQgLS0tLS0gLy9cblxuLy8gcmVxdWlyZWQgZm9yIGpRdWVyeSBicmlkZ2V0XG5wcm90by5faW5pdCA9IG5vb3A7XG5cbmlmICggalF1ZXJ5ICYmIGpRdWVyeS5icmlkZ2V0ICkge1xuICBqUXVlcnkuYnJpZGdldCggJ2RyYWdnYWJpbGx5JywgRHJhZ2dhYmlsbHkgKTtcbn1cblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBEcmFnZ2FiaWxseTtcblxufSApICk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/draggabilly/draggabilly.js\n");

/***/ })

};
;